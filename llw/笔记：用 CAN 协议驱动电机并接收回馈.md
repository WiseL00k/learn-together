---
tags:
  - type/concept
  - topic/robomaster
  - topic/control
  - status/done
date: 2026-01-10
---
# 1. CAN 协议

>  **CAN 线是一个靠“极速切换”支撑起的伪并行系统。** 它的本质就是**分时复用**。

我们从控制电机的过程出发，我们首先通过以下指令初始化 CAN0 和 CAN1 设备，比特率为 1Mbits
```Bash
sudo ip link set can0 up type can bitrate 1000000
sudo ip link set can1 up type can bitrate 1000000
```

此处的 1000000 指[比特率](#比特率和波特率)，单位为 bps，表示在 1s 内可以传递 1000000 即 1m 个比特的信息。

初始化后，我们可以通过 cansend 发送数据到 can 口，如：
```Bash
cansend can1 200#5A5A5A5A5A5A5A5A
```

接着我们可以通过 candump 读取对应 can 口的数据，如:
```Bash
candump can0
```
此时返回的数据 belike：
```Bash
can0 200 [8] 5A 5A 5A 5A 5A 5A 5A 5A
```
其中的 200 是我们所发送信息的标识符，后面的一大堆 5A 是我们发送的内容。
我们可以依此对 can 通信建立一个基本的认知：
- 在 can 线上流通的数据是由标识符+数据正文构成的

我们进一步将 can 口连上接着 m3508 电机的 c620 电调，则会发现 candump 读取到的数据一直在变，以标识符为 0x206 的电调为例：
```Bash
can0 206 [8] 19 5A 40 F0 77 18 AC DC
```
这些标识符为 206 的数据就是电机的回馈数据。这时我们再用 cansend 往 can0 发布一条全 0 信号，很可能观察不到 candump 读取数据的改变。这是为什么呢？

> 想象有一屋子的人开会，桌面上只有一个麦克风。那么同一时刻只能有人说话。如果想进行交流，则需要大家轮流使用麦克风。

其实这就是 can 协议的实质：一条 can 线上可以串联多个收发信号的设备，每个设备轮流发送信号，轮流使用麦克风，进而达到相互沟通的效果。为了使大家的沟通有条理，就引入 [can 帧](#can帧)的概念。

根据信息内容的不同，一个can 帧的总长度大约在 **108 位到 128 位** 之间。为了方便工程计算，我们通常取平均值 **125 位**。

依照上文的波特率，我们可以算出传输 1 位用时为 $1 \mu s$，进而可知传输一个 can 帧需要的时间为 $125 \mu s$。

如果我们希望以 1khz 的频率向电机发送控制信号，也就需要每个周期（1个周期 = 1ms）发送一帧，用时 $125 \mu s$ 的控制信号。如此一来 can 总线上一周期还空余 $875\mu s$ 可以给别人发送信号，正好用来给电机发送回馈信号。

参考c620 电调的消息定义，由于控制 m3508 电机就是控制电流，只需要两个 16 进制位就可以控制一个电机的电流值。故而**同一帧内可以有 4 个电调的控制信号**，以此可以降低电调之间的控制延迟。

下面贴出手册相关的表格以供参考，要注意这里的一个 DATA 数据域包含两个 16 进制数。
![[images/Pasted image 20251230181911.png]]

![[images/Pasted image 20251230183236.png]]
> 虽然看起来一个 can 总线可以挂 8 个电机，但实际上在 1khz 的频率下 can 总线承受不了这样的负载：can 总线需要在 1ms 内承受 8 个回馈帧和 2 个控制帧，但这里 10 帧的总时间会去到 1.25ms
> 我们可以通过调低频率来解决这个问题

不同帧通过标识符来区分。从上面的手册可以确认所定义的控制帧标识符为 0x1FF 和 0x200，根据电调 id 不同而确定。假设现在我的电调 id 为 6 ,想要发送一条控制指令让电机转起来，指令例：
```bash
cansend 1ff#0000f0f000000000 # 00 00 f0 f0 00 00 00 00，大小写不敏感
```

开头的 `1ff` 是标识符。对应 6 号电调的位置是 DATA[2] 和 DATA[3]，分别代表电流高八位（8 位二进制数等于 2 位十六进制数）和低八位。我们在此输入了 `F0F0`。
手册中提到的控制电流的范围是 **-16384～16384**，对应 **-20A～20A**，其中负数的部分由补码存储。
考虑到 `F0F0` 最高位为 1,说明这是个负数，故还原成原码可知其值为 **-3856**，再映射到 -20A~20A，就知道我们发送了一条约 **-4.7A** 的电流指令

同样地，如果我们想发送一条 **10A** 的电流指令，可以通过以下式子算出：
$$
\frac{10}{20} \times 16384 = 8192 = (0010000000000000)_{2} = (2000)_{16}
$$
对应的指令则为：
```bash
cansend 1ff#0000200000000000 
```
	
现在我们建立了对 can 和使用 can 控制电机的初步认知，知道如何通过 cansend 发送指定的电流指令给指定 id 的电调。

通过这样轮流使用麦克风的协议，can 协议可以在同一条总线上近似并行地传输数据，可以按一定频率的多个控制信号和回馈信号的传输。

# 2.电机参数与指令计算

在上文我们对 can 总线有了一个初步的认知，也学习了如何计算特定电流指令。
同样地，回馈数据也需要经过处理转换到我们常用的单位下。
> 我们的开发统一采用弧度制和国际单位制

参考手册可以知道电调反馈的报文里：
- 角度数据是 **0~8192**，对应 **0～360 度
- 转速单位值为 RPM
- 温度单位为摄氏度

相关的换算可以参考 `actuator_coefficient.yaml`
```yaml
actuator_coefficient:
  rm_3508: # RoboMaster 3508 without reducer
    act2pos: 0.0007669903  # 2PI/8192
    act2vel: 0.1047197551   # 2PI/60
    act2effort: 1.90702994e-5  # 20/16384*0.0156223893
    effort2act: 52437.561519   # 1/act2effort
    max_out: 16384
```

这些值都是什么意思呢？以 `act2pos` 为例，假设我们收到电机回馈的角度数据值 8192，想换算成角度，只需要乘上这个系数：$$8192 \times \frac{2 \pi}{8192} = 2 \pi$$
就得到了弧度制下的电机角度值。
`act2vel` 也是同理，将 RPM单位的转速乘 `act2vel` 可以得到 rad\s 单位的转速。
不过 `act2sffort` 有些特殊，这个参数建立了电流值和扭矩大小的关系。

理论上我们可以通过电机手册中的转矩常数计算电流值对应的扭矩，但在实践中，我们使用
m3508电机时**会拆掉前面的减速箱**，此时不再有减速箱的增扭效果，所以在计算转矩时需要**计算转子单体的转矩常数**。

这可以通过将带减速器的转矩常数除去减速比得到： $0.3 \div (3591/187) \approx 0.0156 \text{ N·m/A}$。

> 减速比的直观理解是，一个减速比为 19 的减速箱在转子转 19 圈后减速箱的输出关节才转 1 圈
> 考虑功率是力矩（扭矩）与角速度的乘积：$P = T \cdot \omega$ ，所以功率一定时，转速越小扭矩越大。

| **参数名称**        | **数值**              | **单位**  |
| --------------- | ------------------- | ------- |
| **额定电压**        | 24                  | V       |
| **转矩常数**        | 0.3                 | N·m/A   |
| **转速常数**        | 24.48               | rpm/V   |
| **转速转矩梯度**      | 72                  | rpm/N·m |
| **机械时间常数**      | 49                  | ms      |
| **相电阻**         | 0.194               | Ω       |
| **相电感**         | 0.097               | mH      |
| **使用环境温度**      | 0 至 50              | ℃       |
| **绕组最高允许温度**    | 125                 | ℃       |
| **极对数**         | 7                   | -       |
| **最大径向载荷（动载荷）** | 210                 | N       |
| **减速电机重量**      | 365                 | g       |
| **减速比**         | 3591/187 (约 19.2:1) | -       |
通过以上系数的计算，我们可以编写程序进行 can通信，进而建立电机硬件的抽象。这样之后的开发中就只需要确定需要的扭矩即可控制电机。

---

## 比特率和波特率

**比特率**（bitrate）衡量的是单位时间内传输的二进制位数，即单位时间内传输了多少比特（多少个 0 或 1）。比特率的单位一般采用 bps，即比特每秒。

can 协议通过**差分信号**进行比特位的传输。即判断两条线的**电平差**。
- 当电平相同时（CAN_H 和 CAN_L 都约为 2.5v，电位差 $V_{diff}=0$），信号为**隐性**信号，逻辑上视为 1；
- 当电平不同时（CAN_H 约为 3.5V，CAN_L 约为 1.5V，电位差 $V_{diff}=2V$），信号为**显性**信号，逻辑上视为 0；

进一步引入**码元**这一概念。can 协议是通过两种电平差值表示两种状态，如果我们引入更多的电平差含义呢？譬如多进制电平（如 PAM4）使得：
- 0V 对应 `00`
- 1.6V 对应 `01`
- 3.3V 对应 `10`
- 5V 对应 `11`
那么同一时刻的电平可以表示 4 种状态，也就是两个 0 或 1，即两比特。
码元指的就是**同一时刻的信号所表示的符号**。根据协议的不同，一码元中包含的比特数也有所不同。
如上文所说：can 协议的 1 码元就是 1 比特，PAM4 里 1 码元等于 2 比特

有了码元，我们进一步可以引出**波特率**（Baud Rate）这一概念。波特率衡量的是单位时间内传输的**符号个数**。想要将波特率转换为比特率，就需要知道在这一协议里一码元包含几个比特。

回到 can 协议，一码元就是一比特，所以 1000000 波特率也是 1000000 比特率。

---
## can帧

一个 can 帧包含以下内容
#### 1. 帧起始 (SOF - Start of Frame)
- **长度**：1 bit
- **状态**：显性电平（0）
- **作用**：告诉总线上所有节点：“注意，我要开始说话了！”。它用于同步所有节点的时钟。
#### 2. 仲裁段 (Arbitration Field)
- **长度**：12 bit（11 位 ID + 1 位 RTR）
- **ID (Identifier)**：就是你之前提到的 `0x1FF` 这种标识符。
    - **优先级逻辑**：ID 越小，优先级越高。因为 0 是显性，当两个节点同时发 ID 时，谁先出现 0，谁就抢占了总线。
- **RTR (Remote Transmission Request)**：用于区分**数据帧**（0）和**远程帧**（1）。
#### 3. 控制段 (Control Field)
- **长度**：6 bit
- **IDE**：区分标准帧（0）还是扩展帧（1）。
- **DLC (Data Length Code)**：最重要的部分。它用 4 位二进制表示后面跟着多少字节的数据。
    - 例如：`1000` 表示 8 字节，`0100` 表示 4 字节。
#### 4. 数据段 (Data Field) —— 核心负载
- **长度**：0 ~ 64 bit (0 ~ 8 Byte)，注意 64 个二进制位正好可以表示为 16 个 16 进制数，这也正是我们 cansend 和 candump 所接受的内容.
- **作用**：存放真正的指令。
- **实例**：在你之前的例子里，这 8 个字节就被拆分成了 4 个电机的电流高低八位。
#### 5. 校验段 (CRC Field)
- **长度**：16 bit (15 位 CRC + 1 位界定符)
- **作用**：发送方根据前面所有数据算出一个复杂的数学结果（校验码）。接收方收到后再算一遍，如果不一致，直接舍弃这一帧。
#### 6. 应答段 (ACK Field)
- **长度**：2 bit (1 位 ACK 槽 + 1 位界定符)
- **逻辑**：发送方在此处发一个“隐性（1）”。
- **作用**：如果总线上任何一个节点正确接收了这一帧，它会在这一瞬间强行把总线压成“显性（0）”。
- **意义**：发送方如果看到 ACK 位变成了 0，就知道：“OK，有人收到我的话了。” 如果还是 1，它会报错并重发。
#### 7. 帧结束 (EOF - End of Frame)
- **长度**：7 bit
- **状态**：连续 7 个隐性电平（1）。
- **作用**：标志着这一帧结束，总线进入空闲状态。
