# LQR控制器设计与实现总结

## 概述

沿用多环串级PID平衡小车的URDF文件，在此基础完成LQR控制器的设计，核心难点为状态空间方程的构建、求解增益矩阵K以及后续调整权重系数以达到更好的控制效果

## 建模过程

### 参数辨析

在倒立摆模型中需要区分“重心高度”与“动力学力臂”这两个概念。

当URDF中描述的重心高度远大于力臂时，由于拟合比例，即使二者在空间状态方程构建过程中混淆使用，也可以取得可观的控制效果，但后续难以通过死磕权重系数取得更好的控制效果。同时重心高度的计算一般忽略轮子，仅对除轮子外的车体进行重心的估算拟合，此处需要一个合理的轮与车体质量比例。

在初期计算中我误用了重心高度作为力臂带入拉格朗日方程，在cpp文件内的CompoterLqr函数中计算出的重心力矩过大，LQR增益失效导致在后续无效调参中花费了不少时间。

同时，在简单一阶倒立摆模型中手写函数计算增益矩阵是不必要的，对于一个简单固定模型可以通过matlab或python包装好的库函数去计算增益矩阵。

### 状态向量定义

为了方便与 ROS 的 `hardware_interface` 对接，系统状态向量 **\$x\$** 定义为：

\$\$x = [\\theta, \\dot{\\theta}, x, \\dot{x}]^T\$\$

* **\$\\theta\$**: 车体倾角 (Pitch)，**0 度为平衡点**（匀速过程中taget_pitch=0是合理的，可以为了提高控制精度而在加速过程中用相关函数计算临时的taget_pitch）
* **\$\\dot{\\theta}\$**: 车体角速度 (由 IMU 直接提供)。
* **\$x\$**: 车体位移 (由速度指令积分计算)。
* **\$\\dot{x}\$**: 车体线速度。

正负号的确认也是极关键的一环

## LQR增益计算（Python control库）

初期尝试手动求解，但是手动求解黎卡提方程极其复杂且容易出错，最后采用 Python 的 `control` 库进行计算

### 权重矩阵 Q 的调试

LQR 的核心在于权衡“状态误差”与“控制代价”。通过多次仿真与实机调试，总结出以下权重调节经验：

1. **角度权重 (**\$Q\_{\\theta}\$**)**: **最高优先级**。必须设得非常大（如 400\~800），因为平衡车一旦倒下，位置和速度就毫无意义。
2. **位置权重 (**\$Q\_{x}\$**)**: **次级优先级**。设得较小（如 10\~30），允许小车为了保持平衡而发生位移漂移。
3. **控制代价 (**\$R\$**)**: 决定了控制的“暴力”程度。
   * **\$R\$** 过大 **\$\\rightarrow\$** 输出软弱，拉不回车头。
   * **\$R\$** 过小 **\$\\rightarrow\$** 输出饱和，电机疯狂震荡或计算发散。

### 增益计算脚本

#### 1.构建动力学矩阵 A, B (基于线性倒立摆模型)

#### 2. 定义权重

Q = np.diag([30, 6.0, 400, 8.0]) # [Pos, Vel, Theta, Omega]
R = 8

#### 3. 库函数直接求解

K, S, E = control.lqr(A, B, Q, R)
print(f"Calculated K: {K}")

### 状态变量的对齐

计算得到的K矩阵在控制器中需要与各状态参数一一对齐，否则权重系数白调。

## 后续优化思路

这是初次探索PID之外的控制算法，对lqr的了解还只能说是皮毛。

目前我对这个控制器的进一步想法是在搭建云台后，再次尝试控制器内ComputerLqr函数实时计算K，将云台pitch与yaw纳入状态空间方程构建需要考虑的变量。当然目前搭建好云台后，只是调整一下力臂长度就能取得不错的控制效果，这个想法暂且搁置，因为我还在补相关的数学与物理知识。

## 多环串级PID与LQR控制的区别

**我原本觉得控制器里的LQR就是一个超大杯的串级PID，后来还是能写出二者的区别**

### 1.核心控制理念

#### PID：无模型的“条件反射”

**理念**：PID 不需要知道小车有多重、轮子惯量是多少。它只关注**误差**。如果偏了（P），就用力推回来；如果偏久了（I），就加大力度；如果偏得快（D），就反向阻尼。

**代码体现**：在 `balance_controller.cpp` 中，我们完全看不到质量 `m`、重力 `g` 或力臂 `l` 的参与。控制律纯粹基于误差计算

#### LQR：基于模型的“全局最优”

**理念**：LQR 必须“懂”物理，同时对模型的物理精度有极高要求。它基于状态空间方程 **\$\\dot{x} = Ax + Bu\$**，通过求解黎卡提方程找到一个 **\$K\$** 矩阵，使得系统在恢复平衡的过程中，**状态偏差**和**能量消耗**的总代价最小。

**代码体现**：Python 脚本 `lqr.py` 依赖物理参数（M, m, l, I, g）。如果 `l`（力臂）定义错了，LQR 算出的 **\$K\$** 就完全失效。

### 2.控制结构

#### PID：串级控制 

**结构**：**将系统强行拆解**。平衡车本质上是位置和角度高度耦合的，但 PID 将其拆分为“速度环”和“直立环”。

1. **外环（速度环）**：根据速度误差，计算出小车应该保持的“目标倾角” (`target_pitch`)。
2. **内环（直立环）**：根据当前倾角与目标倾角的误差，计算电机力矩。

**缺点**：参数整定从内到外，相互制约。如果外环响应太快，可能会破坏内环的稳定性。

#### LQR：全状态反馈 (Full State Feedback)

**结构**：**并行处理所有状态**。位置、速度、角度、角速度被视为一个整体向量 **\$x\$**。LQR 一次性计算出 **\$u\$**，同时兼顾了“保持平衡”和“回到原点”。它利用了系统的**耦合特性**（比如知道要向前加速才能产生向后的反作用力来平衡）。

### 3. 调参逻辑：时域试凑 vs. 频域代价

#### PID：调节“响应形状”

**关注点**：超调量、上升时间、稳态误差。

**过程**：

1. 先调内环 **\$K\_p\$** 让车支棱起来，加 **\$K\_d\$** 消除震荡。
2. 再调外环 **\$K\_p\$** 让车能走，加 **\$K\_i\$** 消除静差。
3. 参数之间往往是孤立调节的

#### LQR：调节“重要程度”

**关注点**：更在乎“站得直”（角度误差）还是“跑得慢”（能量/速度误差）

**过程**：

1. 在 Python 脚本中调整权重矩阵 **\$Q\$** 和 **\$R\$**。
2. **实战心得**：在你的 `lqr.py` 中，角度权重给了 `400`，而位置权重只有 `30`。这非常直观地告诉控制器：“无论发生什么，优先保住角度平衡，位置偏一点没关系”。
3. **\$R\$** 值决定了控制的“刚性”。**\$R\$** 越小，电机输出越果断。

### 4. 鲁棒性与适应性

#### PID 的优势与局限

**优势**：**抗模型误差能力强**。即使你把车上加一块砖头（改变质量），PID 只要积分项 **\$I\$** 还在，大概率还能稳住，虽然性能会变差。

**局限**：**多目标冲突**。当你既想让它快速归位，又想让它不大幅摆动时，PID 很难找到平衡点，容易顾此失彼。

#### LQR 的优势与局限

**优势**：**处理多变量耦合能力极强**。倒立摆系统是一个典型的“非最小相位系统”（想向左走，必须先向右加速让车倒过来）。LQR 的数学推导天然包含这种动力学特性，因此在处理大角度扰动或快速跟踪时，LQR 往往比 PID 更顺滑、更“聪明”。

**局限**：**对模型依赖极高**。正如我们在调试中发现的，如果力臂 **\$l\$** 算错了，或者正负号（极性）搞反了，LQR 会直接失效。
